package me.raska.opendvs.worker.poller;

import java.io.IOException;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;
import java.util.zip.GZIPInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import lombok.extern.slf4j.Slf4j;
import me.raska.opendvs.base.model.Vulnerability;
import me.raska.opendvs.base.model.Vulnerability.Severity;
import me.raska.opendvs.base.model.poller.PollerAction;
import me.raska.opendvs.base.model.poller.PollerActionStep;
import me.raska.opendvs.base.poller.NativePoller;

@Slf4j
public class CveVulnerabilityPoller implements NativePoller {
    private static final SimpleDateFormat XMLDATE_SDF = new SimpleDateFormat("yyyy-mm-dd'T'HH:mm:ss.SSSX");

    private DocumentBuilder docBuilder;
    private XPathExpression entryProductList;
    private XPathExpression entryPublished;
    private XPathExpression entryModified;
    private XPathExpression entryId;
    private XPathExpression entryScore;
    private XPathExpression entryVector;
    private XPathExpression entryComplexity;
    private XPathExpression entryRefs;
    private XPathExpression entryDescription;

    public CveVulnerabilityPoller() throws ParserConfigurationException, XPathExpressionException {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        this.docBuilder = dbFactory.newDocumentBuilder();

        XPathFactory xPathfactory = XPathFactory.newInstance();
        XPath xpath = xPathfactory.newXPath();
        entryProductList = xpath.compile("./vulnerable-software-list/product/text()");
        entryPublished = xpath.compile("./published-datetime/text()");
        entryModified = xpath.compile("./last-modified-datetime/text()");
        entryId = xpath.compile("./cve-id/text()");
        entryScore = xpath.compile("./cvss/base_metrics/score/text()");
        entryVector = xpath.compile("./cvss/base_metrics/access-vector/text()");
        entryComplexity = xpath.compile("./cvss/base_metrics/access-complexity/text()");
        entryRefs = xpath.compile("./references/reference/@href");
        entryDescription = xpath.compile("./summary/text()");
    }

    private void fetchCveEntries(String actionId, Consumer<PollerAction> callback, String modifier) {
        final PollerAction action = new PollerAction();
        action.setId(actionId);

        final PollerActionStep step = new PollerActionStep();
        step.setState(PollerActionStep.State.SUCCESS);
        step.setType(PollerActionStep.Type.VULNERABILITY);
        step.setDetectedVulnerabilities(new HashSet<>());

        try {
            URL cve = new URL("https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-" + modifier + ".xml.gz");

            Document doc = docBuilder.parse(new GZIPInputStream(cve.openStream()));
            NodeList entries = doc.getElementsByTagName("entry");
            for (int i = 0; i < entries.getLength(); i++) {
                try {
                    step.getDetectedVulnerabilities().add(parseCveEntry(entries.item(i)));
                } catch (XPathExpressionException | ParseException e) {
                    log.info("Cannot parse vulnerability", e);
                }
            }
        } catch (SAXException | IOException e) {
            log.error("Cannot parse CVE entries with modifier " + modifier + " for action " + actionId, e);
            step.setState(PollerActionStep.State.FAILURE);
        }

        log.info("Fetched " + step.getDetectedVulnerabilities().size() + " vulnerabilities and ending with state "
                + step.getState());
        action.setSteps(Arrays.asList(step));
        callback.accept(action);
    }

    private Set<String> extractStrings(NodeList nodelist) {
        final Set<String> strings = new HashSet<>();
        for (int i = 0; i < nodelist.getLength(); i++) {
            strings.add(nodelist.item(i).getNodeValue());
        }
        return strings;
    }

    private Severity getSeverity(String complexity) {
        try {
            return Severity.valueOf(complexity);
        } catch (IllegalArgumentException e) {
            return Severity.UNKNOWN;
        }
    }

    private Vulnerability parseCveEntry(Node item) throws XPathExpressionException, ParseException {
        final Vulnerability vuln = new Vulnerability();

        String id = (String) entryId.evaluate(item, XPathConstants.STRING);
        Double score = (Double) entryScore.evaluate(item, XPathConstants.NUMBER);
        String vector = (String) entryVector.evaluate(item, XPathConstants.STRING);
        String complexity = (String) entryComplexity.evaluate(item, XPathConstants.STRING);
        NodeList xmlRefs = (NodeList) entryRefs.evaluate(item, XPathConstants.NODESET);
        String description = (String) entryDescription.evaluate(item, XPathConstants.STRING);
        String modified = (String) entryModified.evaluate(item, XPathConstants.STRING);
        String published = (String) entryPublished.evaluate(item, XPathConstants.STRING);
        NodeList xmlProducts = (NodeList) entryProductList.evaluate(item, XPathConstants.NODESET);

        vuln.setId(id);
        if (!score.isNaN()) {
            vuln.setScore(score);
        } else {
            log.warn("Obtained score for " + id + " which is not a number: " + score.toString() + " - "
                    + entryScore.evaluate(item, XPathConstants.STRING));
        }
        vuln.setVector(vector);
        vuln.setSeverity(getSeverity(complexity));
        vuln.setDescription(description);
        vuln.setUpdated(XMLDATE_SDF.parse(modified));
        vuln.setPublished(XMLDATE_SDF.parse(published));
        vuln.setRefs(extractStrings(xmlRefs));
        vuln.setProducts(extractStrings(xmlProducts));
        vuln.setSynced(new Date());
        vuln.setSource("NVD");

        return vuln;
    }

    @Override
    public void process(PollerAction action, Consumer<PollerAction> callback) {
        if (action.getFilter() != null && action.getFilter().startsWith("cve:")) {
            log.info("Triggering CVE NIST due to filter {}", action.getFilter());
            fetchCveEntries(action.getId(), callback, action.getFilter().substring(4));
        } else if (log.isDebugEnabled()) {
            log.debug("Filter " + action.getFilter() + " is not applicable for Maven poller");
        }
    }

    @Override
    public String getId() {
        return "cve_nist";
    }

}
